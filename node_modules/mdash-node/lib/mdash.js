
/*
mdash
https://github.com/semencov/mdash-node

Copyright (c) 2015 Yuri Sementsov
Licensed under the MIT license.
 */

(function() {
  'use strict';
  var Lib, Mdash, fs, path, readFile, settingsFile, tretsDir;

  path = require('path');

  fs = require('fs');

  Lib = require('./lib');

  settingsFile = path.join(process.cwd(), ".mdash");

  tretsDir = path.join(__dirname, './trets');

  readFile = function(filepath) {
    var contents, e, result;
    contents = void 0;
    result = void 0;
    try {
      contents = fs.readFileSync(String(filepath));
      try {
        result = JSON.parse(contents);
      } catch (_error) {
        e = _error;
        return {};
      }
      return result;
    } catch (_error) {
      e = _error;
      return {};
    }
  };

  module.exports = Mdash = (function() {
    Mdash.prototype.presets = {
      'Quote': {
        no_bdquotes: false,
        no_inches: false
      },
      'OptAlign': {
        disabled: true
      },
      'Text': {
        disabled: true
      },
      'Dash.ka_de_kas': {
        disabled: true
      },
      'Date.mdash_month_interval': {
        disabled: true
      },
      'Date.nbsp_and_dash_month_interval': {
        disabled: true
      },
      'Nobr.hyphen_nowrap_in_small_words': {
        disabled: true
      },
      'Nobr.hyphen_nowrap': {
        disabled: true
      },
      'Punctmark.dot_on_end': {
        disabled: true
      },
      'Space.clear_before_after_punct': {
        selector: 'Space.remove_space_before_punctuationmarks'
      },
      'Space.autospace_after': {
        selector: 'Space.autospace_after_*'
      },
      'Space.bracket_fix': {
        selector: ['Space.nbsp_before_open_quote', 'Punctmark.fix_brackets']
      },
      'Etc.unicode': {
        selector: '*',
        dounicode: true,
        disabled: true
      }
    };

    function Mdash(text, options) {
      var self;
      if (options == null) {
        options = {};
      }
      self = this;
      if (typeof text === 'object') {
        options = text;
        text = null;
      }
      options = Lib.merge(readFile(settingsFile), options);
      this.inited = false;
      this.text = text;
      this.trets = {};
      this.tretsOrder = [];
      fs.readdirSync(tretsDir).forEach(function(file) {
        var e, name, tret;
        try {
          tret = require("" + tretsDir + "/" + file);
          if (tret.__super__.constructor.name === 'Tret') {
            name = tret.prototype.constructor.name;
            if (self.trets[name] == null) {
              self.trets[name] = new tret();
              return self.tretsOrder.push(name);
            }
          }
        } catch (_error) {
          e = _error;
        }
      });
      this.tretsOrder.sort(function(a, b) {
        return self.trets[a].order - self.trets[b].order;
      });
      this.settings = {};
      this.blocks = [];
      if ((options != null) && typeof options === 'object') {
        this.setup(options);
      }
      return;
    }


    /*
     * Задаём текст для применения типографа
     *
     * @param string $text
     */

    Mdash.prototype.setText = function(text) {
      return this.text = text;
    };


    /*
     * Установлена ли настройка
     *
     * @param string $key
     */

    Mdash.prototype.isOn = function(key) {
      var _ref, _ref1;
      if (((_ref = this.settings["*"]) != null ? _ref[key] : void 0) == null) {
        return false;
      }
      return (_ref1 = ("" + this.settings["*"][key]).toLowerCase()) === "on" || _ref1 === "true" || _ref1 === "1" || _ref1 === "direct";
    };

    Mdash.prototype.getTretNames = function() {
      return this.tretsOrder;
    };

    Mdash.prototype.getRuleNames = function(mask) {
      var result, ruleNames, self, tret, tretNames, _i, _len;
      self = this;
      result = {};
      tretNames = this.getTretNames();
      for (_i = 0, _len = tretNames.length; _i < _len; _i++) {
        tret = tretNames[_i];
        ruleNames = this.trets[tret].getRuleNames();
        result[tret] = ruleNames;
      }
      if (mask) {
        return Lib.selectRules(mask, result);
      } else {
        return result;
      }
    };

    Mdash.prototype.getSettings = function() {
      return this.settings;
    };

    Mdash.prototype.getRuleSettings = function() {
      var rule, ruleList, ruleNames, rules, selector, settings, tret, value, _i, _len, _ref;
      settings = {};
      ruleNames = this.getRuleNames();
      _ref = this.settings;
      for (selector in _ref) {
        value = _ref[selector];
        ruleList = Lib.selectRules(selector, ruleNames);
        for (tret in ruleList) {
          rules = ruleList[tret];
          if (settings[tret] == null) {
            settings[tret] = {};
          }
          for (_i = 0, _len = rules.length; _i < _len; _i++) {
            rule = rules[_i];
            settings[tret][rule] = (settings[tret][rule] != null ? Lib.merge(settings[tret][rule], value) : value);
          }
        }
      }
      return settings;
    };


    /*
     * Установить настройки
     *
     * @param array $setupmap
     */

    Mdash.prototype.setup = function(options) {
      var k, selector, v, value, _ref;
      if (options == null) {
        options = {};
      }
      this.settings = Lib.merge(Lib.processSettings(this.presets), this.settings);
      options = Lib.processSettings(options, this.presets);
      for (selector in options) {
        value = options[selector];
        if (value['disabled'] != null) {
          _ref = this.settings;
          for (k in _ref) {
            v = _ref[k];
            if (selector !== "*" && new RegExp("^" + selector + "\.?", 'i').test(k) && (v['disabled'] != null)) {
              if (Object.keys(v).length === 1) {
                delete this.settings[k];
              } else {
                this.settings[k]['disabled'] = value['disabled'];
              }
            }
          }
        }
        value = Lib.merge(this.settings[selector] || {}, value) || {};
        if (Object.keys(value).length > 0) {
          this.settings[selector] = value;
        }
      }
      if (!this.inited) {
        this.init();
      }
    };

    Mdash.prototype.init = function() {
      var self;
      self = this;
      if (!this.inited) {
        this.blocks.push(Lib.addSafeBlock('pre'));
        this.blocks.push(Lib.addSafeBlock('code'));
        this.blocks.push(Lib.addSafeBlock('script'));
        this.blocks.push(Lib.addSafeBlock('style'));
        this.blocks.push(Lib.addSafeBlock('notg'));
        this.blocks.push(Lib.addSafeBlock('span-notg', ['<span class="_notg_start"></span>', '<span class="_notg_end"></span>']));
      }
      this.inited = true;
    };


    /*
     * Prepare text before applying rules:
     * - encrypt HTML tags
     * - encrypt content inside safe tags
     * - normilize special chars and entities
     */

    Mdash.prototype.beforeFormat = function(text) {
      if (text == null) {
        throw new Error("Text is undefined");
      }
      text = Lib.processSafeBlocks(text, this.blocks, Lib.encode);
      text = Lib.processTags(text, Lib.encode);
      text = Lib.clearSpecialChars(text);
      return text.trim();
    };


    /*
     * Clean text after applying rules:
     * - decrypt HTML tags
     * - decript content in safe tags
     */

    Mdash.prototype.afterFormat = function(text) {
      var repl;
      if (text == null) {
        throw new Error("Text is undefined after format");
      }
      text = Lib.decodeInternalBlocks(text);
      if (this.isOn('dounicode')) {
        text = Lib.convertEntitiesToUnicode(text);
      }
      text = Lib.processTags(text, Lib.decode);
      text = Lib.processSafeBlocks(text, this.blocks, Lib.decode, true);
      if (!this.disable_notg_replace) {
        repl = ['<span class="_notg_start"></span>', '<span class="_notg_end"></span>'];
        if (this.remove_notg) {
          repl = "";
        }
        text = text.replace(['<notg>', '</notg>'], repl);
      }
      return text.trim();
    };


    /*
     * Запустить типограф на выполнение
     *
     */

    Mdash.prototype.format = function() {
      var args, callback, e, err, options, settings, text, tretName, tretObj, _i, _len, _ref;
      err = null;
      args = [].slice.apply(arguments);
      callback = typeof args.slice(-1)[0] === 'function' ? args.pop() : null;
      options = typeof args.slice(-1)[0] === 'object' ? args.pop() : null;
      text = typeof args.slice(-1)[0] === 'string' ? args.pop() : null;
      try {
        if (text != null) {
          this.setText(text);
        }
        if ((options != null) && typeof options === 'object') {
          this.setup(options);
        }
        this.text = this.beforeFormat(this.text);
        settings = this.getRuleSettings();
        _ref = this.tretsOrder;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          tretName = _ref[_i];
          tretObj = this.trets[tretName];
          this.text = tretObj.apply(this.text, settings[tretName]);
        }
        this.text = this.afterFormat(this.text);
      } catch (_error) {
        e = _error;
        err = e;
      }
      if ((callback != null) && typeof callback === 'function') {
        return callback(err, this.text);
      } else {
        return this.text;
      }
    };

    Mdash.prototype.getStyles = Mdash.getStyles = function(list) {
      if (list == null) {
        list = false;
      }
      return Lib.styles(list);
    };


    /*
     * Установить режим разметки,
     *   Lib.LAYOUT_STYLE - с помощью стилей
     *   Lib.LAYOUT_CLASS - с помощью классов
     *   Lib.LAYOUT_STYLE|Lib.LAYOUT_CLASS - оба метода
     *
     * @param int $layout
     */

    Mdash.prototype.setLayout = Mdash.setLayout = function(layout) {
      if (layout == null) {
        layout = Lib.LAYOUT_STYLE;
      }
      return Lib.LAYOUT = layout;
    };


    /*
     * Установить префикс для классов
     *
     * @param string|bool $prefix если true то префикс 'mdash_', иначе то, что передали
     */

    Mdash.prototype.setLayoutClassPrefix = Mdash.setLayoutClassPrefix = function(prefix) {
      if (prefix != null) {
        return Lib.LAYOUT_CLASS_PREFIX = prefix;
      }
    };


    /*
     * Запустить типограф
     *
     * @param string $text
     * @param array $options
     * @return string
     */

    Mdash.format = function() {
      var args, inst;
      args = [].slice.apply(arguments);
      inst = new this();
      return inst.format.apply(inst, args);
    };

    Mdash.getTretNames = function(short) {
      if (short == null) {
        short = true;
      }
      return this.prototype.getTretNames(short);
    };

    Mdash.getRuleNames = function(mask) {
      return this.prototype.getRuleNames(mask);
    };

    Mdash.LAYOUT_STYLE = Lib.LAYOUT_STYLE;

    Mdash.LAYOUT_CLASS = Lib.LAYOUT_CLASS;

    return Mdash;

  })();

}).call(this);
